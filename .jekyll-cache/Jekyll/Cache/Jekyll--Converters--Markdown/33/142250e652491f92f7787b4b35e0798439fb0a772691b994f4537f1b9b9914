I"<h3 id="1-沙盒sandbox模式">1. 沙盒(<code class="highlighter-rouge">sandbox</code>)模式</h3>
<ul>
  <li>
    <h4 id="可用沙盒模式进行测试rails-c---sandbox">可用沙盒模式进行测试，<code class="highlighter-rouge">rails c --sandbox</code></h4>
  </li>
</ul>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> <span class="c1"># Any modifications you make will be rolled back on exit</span></code></pre></figure>

<ul>
  <li>
    <h4 id="sandbox-模式会模拟-增删改-数据以及关联关系并不会提交事务所以不会插入到库-所有的操作都会在退出的时候-rollback"><code class="highlighter-rouge">sandbox</code> 模式，会模拟 增删改 数据以及关联关系，并不会提交事务，所以不会插入到库， 所有的操作都会在退出的时候 <code class="highlighter-rouge">rollback</code></h4>
  </li>
</ul>

<h3 id="2-delete_all">2. <code class="highlighter-rouge">delete_all</code></h3>
<ul>
  <li>
    <h4 id="delete_all-不会走-callback-会直接生成一条-delete-sql-语句比如"><code class="highlighter-rouge">delete_all</code> 不会走 <code class="highlighter-rouge">callback</code>, 会直接生成一条 <code class="highlighter-rouge">delete SQL</code> 语句，比如：</h4>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> <span class="no">Project</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">delete_all</span>
<span class="c1">#=&gt; DELETE FROM "PROJECTS" WHERE "PROJECTS"."ID" = :a1  [["id", 1]]</span></code></pre></figure>

<h3 id="3-destroy_all">3. <code class="highlighter-rouge">destroy_all</code></h3>
<ul>
  <li>
    <h4 id="destroy_all"><code class="highlighter-rouge">destroy_all</code></h4>
  </li>
</ul>

<p>destroy_all 会走 callback（相关的数据也都删除）, 会生成多条 delete SQL 语句
Project.where(id: [1, 2]).delete_all</p>
<h1 id="delete-from-projects-where-projectsid--a1--id-1">DELETE FROM “PROJECTS” WHERE “PROJECTS”.”ID” = :a1  [[“id”, 1]]</h1>
<h1 id="delete-from-projects-where-projectsid--a1--id-2">DELETE FROM “PROJECTS” WHERE “PROJECTS”.”ID” = :a1  [[“id”, 2]]</h1>

<p>同时也会把模型中 has_many 配置了 dependent: :delete_all 或者 dependent: :destroy 的给删除掉</p>

<p>dependent: :delete_all, 会生成一条 delete SQL 语句, has_many 全部删除, 不会走 callback</p>
<h1 id="delete-from-project_extra_properties-where-project_extra_propertiesproject_id--a1--project_id-1">DELETE FROM “PROJECT_EXTRA_PROPERTIES” WHERE “PROJECT_EXTRA_PROPERTIES”.”PROJECT_ID” = :a1  [[“project_id”, 1]]</h1>

<p>dependent: :destroy 会生成多条 delete SQL 语句, has_many 全部删除, 会走 callback（相关的数据也都删除）</p>
<h1 id="delete-from-project_extra_properties-where-project_extra_propertiesid--a1--id-1804">DELETE FROM “PROJECT_EXTRA_PROPERTIES” WHERE “PROJECT_EXTRA_PROPERTIES”.”ID” = :a1  [[“id”, 1804]]</h1>
<h1 id="delete-from-project_extra_properties-where-project_extra_propertiesid--a1--id-1803">DELETE FROM “PROJECT_EXTRA_PROPERTIES” WHERE “PROJECT_EXTRA_PROPERTIES”.”ID” = :a1  [[“id”, 1803]]</h1>

<p>特别注意：
Project.find(1).project_extra_properties.delete_all, 并不一定会生成一条 delete SQL 语句</p>

<ol>
  <li>如果你的 has_many 配置了 dependent 参数 dependent: :destroy 或者 dependent: :delete_all
会生成一条 delete SQL 语句
    <h1 id="delete-from-project_extra_properties-where-project_extra_propertiesproject_id--a1--project_id-1-1">DELETE FROM “PROJECT_EXTRA_PROPERTIES” WHERE “PROJECT_EXTRA_PROPERTIES”.”PROJECT_ID” = :a1  [[“project_id”, 1]]</h1>
  </li>
  <li>如果你的 has_many 没有配置 dependent: :destroy
而是会生成一条 update SQL 语句
    <h1 id="update-project_extra_properties-set-project_extra_propertiesproject_id--null-where-project_extra_propertiesproject_id--a1--project_id-1">UPDATE “PROJECT_EXTRA_PROPERTIES” SET “PROJECT_EXTRA_PROPERTIES”.”PROJECT_ID” = NULL WHERE “PROJECT_EXTRA_PROPERTIES”.”PROJECT_ID” = :a1  [[“project_id”, 1]]</h1>
  </li>
</ol>

:ET